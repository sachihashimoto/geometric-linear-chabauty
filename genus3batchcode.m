AttachSpec("G3Hyp.spec");
load "../Coleman/coleman.m"; 
load "mws_qc.m"; 

/*

This is code associated to the paper 'A Geometric Linear Chabauty Comparison Theorem' by Hashimoto and Spelier.

As written, the program tries to find curves with non-rational points ruled out by geometric Chabauty but not by Chabauty--Coleman.
In particular, it checks for curves where not all points pass the Mordell--Weil sieve. In this case to see a diffrence in the methods, 
we must have bad reduction of the Mordell--Weil group (See Theorem 5.1).
We used this code to compute Example 5.8. A slight modification to the code produces Example 5.7, or custom geometric linear Chabauty computations.

Written by Sachi Hashimoto and Pim Spelier; with a function (coordstopoint) by Jennifer Balakrishnan and Jan Tuitman.
*/

debug := true; //true for a more verbose output
found := false;
R<x>:=PolynomialRing(Rationals());
p:= 3;

eps := 10^(-10);
infinity := 10^10;


function makeintegral(P)
	//make the point P have integral coordinates
	if Type(Parent(P[1])) eq Type(Rationals()) then
		R:= pAdicField(p, 20);
		P := [R!P[1], R!P[2], R!P[3]];
	end if;
	V := [Valuation(P[i]) : i in [1 .. 3]];
	MinV := Minimum(V);
	P := [p^(-MinV) * P[1], p^(-MinV)*P[2], p^(-MinV)*P[3]];
	return P;
end function;

function coordstopoint(P, data) 
// For P a p-adic point (an element of H_{Q_p}), calculate the point in the recformat needed for the Coleman integration code of Jennifer Balakrishnan and Jan Tuitman
	P:= makeintegral(P);
	Q:=data`Q; N:=data`N; r:=data`r; W0:=data`W0; Winf:=data`Winf; d:=Degree(Q);
	if GF(p)!P[3] ne GF(p)!0 then
		b0:=[];
		for i:=1 to d do
			bi:=Rationals()!0;
			for j:=1 to d do
				bi:=bi+W0[i,j]*Integers()!(P[2]^(j-1)); 
			end for;
			b0[i]:=Rationals()!bi; 
		end for;
		return set_bad_point(P[1],b0,false,data);	
	else
		//The rest of the coordstopoint function is from Magma code of Jennifer Balakrishnan and Jan Tuitman 
		//from the repository <https://github.com/jtuitman/Coleman>
		Qx:=RationalFunctionField(RationalField()); 
		Qxy:=PolynomialRing(Qx);
		Qfun:=Qxy!0;
		C:=Coefficients(Q);
		for i:=1 to #C do
			D:=Coefficients(C[i]);
			for j:=1 to #D do
				Qfun:=Qfun+D[j]*(Qx.1)^(j-1)*(Qxy.1)^(i-1);
			end for;
		end for;

		FF:=FunctionField(Qfun);
		places:=InfinitePlaces(FF);
		binffun:=[];
		for i:=1 to d do
			bi:=FF!0;
			for j:=1 to d do
				bi:=bi+Winf[i,j]*FF.1^(j-1);
			end for;
			binffun[i]:=bi;
		end for;
		for i:=1 to #places do
			if Degree(places[i]) eq 1 then
				x:=0;
				b:=[];
				for j:=1 to d do
					b[j]:=Evaluate(binffun[j],places[i]);
				end for;
				return set_bad_point(x,b,true,data);
			end if;
		end for;
	end if;
end function;


function logp(A,B,data) 
// calculate log(B-A) as a vector of length 3. Here A,B are given in the recformat
	ints := coleman_integrals_on_basis(A, B, data:e:=40); 
	return Vector([ints[i] : i in [1..3]]);
end function;

function logc(A,B, data)
 // calculate log(B-A) as a vector of length 3. Here A,B are given by coordinates
	return logp(coordstopoint(A,data), coordstopoint(B,data), data);
end function;

function logDiv(T, data) 
// For T a sequence with elements of the form [A_i,B_i,t_i], calculate log(sum_i t_i (A_i - B_i) )
	ans := Vector([0,0,0]); 
	for i in [1..#T] do
		if T[i][3] eq 0 then
			continue;
		end if;
		ans := ans + T[i][3]*logc(T[i][2], T[i][1], data);
	end for;
	return ans;
end function;

liftPoint:=function(non,liftprec,X)
	//lifts an Fp-point non to two different p-adic points on X to the precision liftprec
	Zp :=pAdicRing(p,liftprec);
	S<z> := PolynomialRing(Zp);
	Xp:=ChangeRing(X,GF(p));
	f,h := HyperellipticPolynomials(X);
	try
		x1 := Zp!non[1];
		x2 := Zp!non[1]+p;
		h1:= Zp!Evaluate(h,x1);
		h2:= Zp!Evaluate(h,x2);
		f1:= Zp!Evaluate(f,x1);
		f2:=Zp!Evaluate(f,x2);

		ypoly1 := z^2 +h1 * z - f1;
		ypoly2 := z^2 +h2 * z - f2;
		y1 := HenselLift(ypoly1,Zp!non[2]);
		y2 := HenselLift(ypoly2,Zp!non[2]);
		Qlift1:=[x1,y1,1];
		Qlift2:=[x2,y2,1];
		return [Qlift1,Qlift2];
	catch err
		y1 := Zp!non[2];
		y2 := Zp!non[2]+p;
		xpoly1:= y1^2 + S!h *y1 - S!f;
		xpoly2:= y2^2 + S!h *y2 - S!f;
		x1 := HenselLift(xpoly1,Zp!non[1]);
		x2 := HenselLift(xpoly2,Zp!non[1]);
		Qlift1:=[x1,y1,1];
		Qlift2:=[x2,y2,1];
		return [Qlift1,Qlift2];
	end try;

end function;

function checkcurve(f)
	//main function
	H:= HyperellipticCurve(f);
	print(H);
	htbd:=1000;
	pts:=Points(H:Bound:=htbd);
	N:= 25;
	data:= coleman_data(y^2 - f, p, N);

	if debug then
		print("Calculated points on the curve up to height 1000");
		print(pts);
	end if;

	diffmat:=[[pts[i] - pts[j]: j in [1 .. #pts]]: i in [1 .. #pts]];

	differences := Flat(diffmat);
	basis, M:= ReducedBasisG3(differences);

	if debug then
		print("Calculated LLL-reduced basis of the subgroup generated by the differences");
	end if;

	heights := [CanonicalHeightG3(differences[i]) : i in [1 .. #differences]];    //use this to pick small height generators as candidates for different choice of generators instead of LLL reduction

	for i in [1..#pts] do
		heights[(i-1)*#pts + i] := infinity;
	end for;

	ind1 := 1;
	ind2 := 2;
	if heights[ind1] gt heights[ind2] then
		ind1 := 2;
		ind2 := 1;
	end if;

	for i in [3 .. (#pts^2)] do
		if Abs(heights[i]-heights[ind1]) lt eps or Abs(heights[i]-heights[ind1]) lt eps then
			continue;
		end if;
		if heights[i] lt heights[ind1] then
			ind2 := ind1;
			ind1 := i;
		elif heights[i] lt heights[ind2] then
			ind2 := i;
		end if;
	end for;

	G1 := differences[ind1];
	G2 := differences[ind2];
	P1a := pts[((ind1-1) mod #pts) + 1];
	P1b := pts[((ind1-1) div #pts) + 1];
	P2a := pts[((ind2-1) mod #pts) + 1];
	P2b := pts[((ind2-1) div #pts) + 1];
	sat:=is_saturated_at_p([G1,G2], [], p,10);
	if debug then
		print("Saturated? ")*Sprint(sat);
	end if;
	if not sat then
		error "The subgroup generated by G1 and G2 is not saturated at p";
	end if;

	// G1 and G2 are low height divisors, and G1 = P1a - P1b, G2 = P2a - P2b
	// We can't expect them to generate the MW-group, but we can determine the index of the subgroup H they generate
	if debug then
		print("Calculated low height divisors");
	end if;

	HeightPairingM := HeightPairingMatrixG3(basis);

	HeightPairingH := HeightPairingMatrixG3([G1,G2]);
	reg:= RegulatorG3([G1,G2]);
	indexH := Round(Determinant(HeightPairingH)/Determinant(HeightPairingM)); //how do we know that the HeightPariingM is correct?
	if (indexH mod p) eq 0 then
		error "The subgroup generated by G1 and G2 is of index divisible by p";
	end if;
	if reg eq 0 then
		error "G1 and G2 are linearly dependent";
	end if;
	if debug then
		print("Checked that G1 and G2 are linearly Independent");
		print(reg);
	end if;

	if debug then
		print("Checked the low height divisors generate a subgroup of index not divisible by p");
		print(indexH);
	end if;

	J:= Jacobian(H);
	Jp:= BaseChange(J, GF(p));
	print("Number of points in JFp");
	print(#Jp);
	A, iso:= AbelianGroup(Jp);
	iso := iso^(-1);
	AG1 := iso(Jp!G1);
	AG2 := iso(Jp!G2);

	A:= GenericAbelianGroup(A);
	AG1 := A! AG1;
	AG2 := A! AG2;


	lincombstilde := []; // find all linear combinations of AG1 and AG2 that vanish
	for i in [0 .. #A] do
		for j in [0 .. #A] do
			if i*AG1 + j*AG2 eq A!0 then
				Append(~lincombstilde,[i,j]);
			end if;
		end for;
	end for;

	lincombstilde := LLL(Matrix(lincombstilde))[1..2];

	if debug then
		print("Calculated generating relations for the images of G1 and G2 modulo p");
		print(lincombstilde);
	end if;

	logG1 := logc(P1b, P1a, data);
	logG2 := logc(P2b, P2a, data);

	logG1tilde := 1/p*(lincombstilde[1][1]* logG1 + lincombstilde[1][2]* logG2 );
	logG2tilde := 1/p*(lincombstilde[2][1]* logG1 + lincombstilde[2][2]* logG2 );

	if debug then
		print("Calculated logG1tilde, logG2tilde");
		print(logG1tilde);
		print(logG2tilde);
	end if;

	Hp := ChangeRing(H, GF(p));
	differencesmodp := [A!iso(Jp!differences[i]) : i in [1 .. #differences]];
	subgroup := sub<A | differencesmodp>;
	bp :=Hp!(pts[1]);
	candidates := [x : x in IndexedSetToSequence(Points(Hp)) | A!iso(x-bp) in subgroup];
	residues := [];
	for pt in pts do
		Append(~residues, Hp![GF(p)!pt[1],GF(p)!pt[2], GF(p)!pt[3]]);
	end for;

	nonresidues :=[];
	for x in candidates do
		if x notin residues then
			Append(~nonresidues,x);
		end if;
	end for;

	if #nonresidues eq 0 then
		error "MW-sieve already removes all the non-rational points";
	end if;

	if debug then
		print("Calculated set of non-residues");
		print(nonresidues);
	end if;

	for pt in nonresidues do
		if debug then
			print("Checking the non-residue:");
			print(pt);
		end if;
		liftprec:=7; 
		Qlifts := liftPoint(pt,liftprec,H);
		datalift:= coleman_data(y^2 - f, p, liftprec);
		g := tiny_integrals_on_basis(coordstopoint(Qlifts[1],datalift),coordstopoint(Qlifts[2],data),datalift);
		g := Vector([g[i] : i in [1..3]]);
		if debug then
			print("These are the lifts");
			print(Qlifts);
			print("This is DQ");
			print(1/p*g);
		end if;

		lc,dummy := Representation(differencesmodp, A!iso(pt-bp));
		print("this is T");
		print(lc);
		assert dummy eq 1;
		T := [ [* pts[((i-1) mod #pts) + 1 ], pts[((i-1) div #pts) + 1], lc[i]*] : i in [1.. (#pts)^2] ];
		print(T);
		logT := logDiv(T, data);
		v := logc(pts[1],Qlifts[1], datalift) - logT;
		g:= 1/p*g;
		v:= 1/p*v;
		gbar := [GF(p)!g[i] : i in [1..3]];
		logG1tildebar  := [GF(p)! logG1tilde[i] : i in [1..3]];
		logG2tildebar := [GF(p)! logG2tilde[i] : i in [1 ..3]];
		vbar := Vector([GF(p)!v[i] : i in [1..3]]);
		// Recall we are trying to construct a matrix equation Ax = v. The columns of A are logG1tilde, logG2tilde and g; and v is the just calculated $\log(pt-basepoint - T)$.
		Amat := Matrix([gbar, logG1tildebar ,logG2tildebar]);
		if Determinant(Amat) eq GF(p)!0 then //checks for bad reduction of M0
			try 
				Solution(Amat, vbar);
			catch err
				M0bar := Matrix([logG1tildebar, logG2tildebar]);
				if Rank(M0bar) lt 2 then
					found := true;
					print(Amat);
					print(v);
					print("Celebrate!");
					return found;
				end if;
			end try;
		end if;
	end for;
	return false;
end function;

curves := [-4*x^7 + 13*x^6 - 24*x^5 + 30*x^4 - 26*x^3 + 17*x^2 - 6*x + 1,
4*x^7 + x^6 - 10*x^5 + 5*x^4 + 6*x^3 - 6*x^2 + 1,
4*x^7 + 5*x^6 - 8*x^5 - 6*x^4 + 6*x^3 + x^2 - 2*x + 1,
4*x^7 - 8*x^6 - 4*x^5 + 12*x^4 - 4*x^2 + 1,
4*x^7 - 3*x^6 - 4*x^5 + 6*x^4 - 2*x^3 - 3*x^2 + 2*x + 1,
-4*x^7 - 23*x^6 - 46*x^5 - 39*x^4 - 14*x^3 + 2*x^2 + 4*x + 1,
4*x^7 + 5*x^6 + 6*x^5 + 5*x^4 + 2*x^3 + 2*x^2 + 1,
4*x^7 + 9*x^6 - 6*x^5 - 15*x^4 + 6*x^3 + 6*x^2 - 4*x + 1,
-4*x^7 - 7*x^6 - 6*x^5 + x^4 + 6*x^3 + 6*x^2 + 4*x + 1,
4*x^7 + x^6 - 14*x^5 + x^4 + 14*x^3 - 2*x^2 - 4*x + 1,
4*x^7 - 3*x^6 - 8*x^5 + 10*x^4 + 6*x^3 - 7*x^2 - 2*x + 1,
4*x^7 - 11*x^6 + 18*x^5 - 19*x^4 + 14*x^3 - 6*x^2 + 1,
-4*x^7 + x^6 + 12*x^5 + 2*x^4 - 10*x^3 - 3*x^2 + 2*x + 1,
4*x^7 + 8*x^6 + 4*x^5 - 4*x^4 - 8*x^3 - 4*x^2 + 1,
4*x^7 - 3*x^6 - 10*x^5 + 5*x^4 + 6*x^3 - 2*x^2 + 1,
-4*x^7 + 5*x^6 + 2*x^5 - 7*x^4 + 6*x^3 + 2*x^2 - 4*x + 1,
4*x^7 - 7*x^6 - 8*x^5 + 14*x^4 + 6*x^3 - 7*x^2 - 2*x + 1,
4*x^7 + 4*x^6 - 4*x^5 - 7*x^4 - 2*x^3 + 3*x^2 + 2*x + 1,
4*x^7 - 8*x^5 + 5*x^4 + 6*x^3 - 5*x^2 - 2*x + 1,
4*x^7 + 4*x^6 - 4*x^5 - 8*x^4 - 4*x^3 + 4*x^2 + 4*x + 1,
-4*x^7 + 5*x^6 - 6*x^4 + 6*x^3 + x^2 - 2*x + 1,
-4*x^7 + 9*x^6 + 6*x^5 - 15*x^4 + 2*x^3 + 6*x^2 - 4*x + 1,
4*x^7 - 4*x^6 - 8*x^5 + 9*x^4 + 6*x^3 - 5*x^2 - 2*x + 1,
4*x^7 - 12*x^6 + 20*x^5 - 20*x^4 + 12*x^3 - 4*x^2 + 1]; //a subset of <http://math.mit.edu/~drew/gce_genus3_hyperelliptic.txt>
//reads in a comma separated sequence of curves with integral coefficients, genus 3, provably rank 2
//the last curve is example 5.8 in the paper

output := "GoodExamples";
for i in [1.. #curves] do
	print("\n");
	print("Starting example ") * Sprint(i);
	try 
		cc := checkcurve(curves[i]);
	catch err
		print err;
		cc := false;
	end try;
	if cc then
		Write(output,Sprint(i));
		Write(output,"\n");
	end if;
end for;
